// Asynchronous Programming
// The call stack will run all the synchronous code first and then the event loop will 
// pick the callback methods from callback queues one by one ..put it in the call stack, execute it one 
// by one.
// There is no order of the async call, we will get the async code o/p in random order
/***
 * The Origin: The values for err and data are generated by the Node.js C++ APIs that interact with your computer's operating system.

The "Error-First" Convention: In Node.js, the first argument of a callback is almost always reserved for an error. If there is no error, that first argument will be null or undefined.

The Data: The second argument is where the actual "prize" (the file contents, the database rows, etc.) is delivered.
 */
import fs from 'node:fs';

console.log("First Line")
fs.readFile('File1.txt',Cb1Function)

function Cb1Function(err,data){
    if(err)
    {
        console.log(err)
    }
    else
        console.log(data.toString());
}

fs.readFile('File2.txt',Cb2Function)

function Cb2Function(err,data){
    //  Node.js "populates" these arguments:
    // - If it failed: 'err' becomes an Error object, 'data' is undefined.
    // - If it worked: 'err' is null, 'data' contains the file buffer.
    if(err)
    {
        console.log(err)
    }
    else
        console.log(data.toString())
}

console.log("Last Line")


/*
*Why do we use .toString()?
By default, fs.readFile returns a Buffer (raw binary data). Since humans aren't great at reading binary, we use .toString() to convert those bits and bytes into a readable string.

Pro-tip: You can avoid .toString() entirely by providing an encoding type:
fs.readFile('example.txt', 'utf8', Cb2Function);
*/